/*
  Author: Zhao Lei <bombworm@gmail.com>
 */

/* Generated by re2c 0.13.5 on Wed Sep 28 15:40:15 2011 */
/*
  +----------------------------------------------------------------------+
  | PHP Version 5                                                        |
  +----------------------------------------------------------------------+
  | Copyright (c) 1997-2012 The PHP Group                                |
  +----------------------------------------------------------------------+
  | This source file is subject to version 3.01 of the PHP license,      |
  | that is bundled with this package in the file LICENSE, and is        |
  | available through the world-wide-web at the following url:           |
  | http://www.php.net/license/3_01.txt                                  |
  | If you did not receive a copy of the PHP license and are unable to   |
  | obtain it through the world-wide-web, please send a note to          |
  | license@php.net so we can mail you a copy immediately.               |
  +----------------------------------------------------------------------+
  | Author: Sascha Schumann <sascha@schumann.cx>                         |
  +----------------------------------------------------------------------+
 */

#include <v8.h>
#include <node.h>
#include <string.h>
#include "util.h"
#include "php_var_unserialize.h"

using namespace v8;

#define SIZEOF_LONG		4
#if SIZEOF_LONG == 4
#define MAX_LENGTH_OF_LONG 11
static const char long_min_digits[] = "2147483648";
#elif SIZEOF_LONG == 8
#define MAX_LENGTH_OF_LONG 20
static const char long_min_digits[] = "9223372036854775808";
#else
#error "Unknown SIZEOF_LONG"
#endif

static inline long parse_iv2(const unsigned char *p, const unsigned char **q) {
    char cursor;
    long result = 0;
    int neg = 0;

    switch (*p) {
        case '-':
            neg++;
            /* fall-through */
        case '+':
            p++;
    }

    while (1) {
        cursor = (char) *p;
        if (cursor >= '0' && cursor <= '9') {
            result = result * 10 + (size_t) (cursor - (unsigned char) '0');
        } else {
            break;
        }
        p++;
    }
    if (q) *q = p;
    if (neg) return -result;
    return result;
}

static inline long parse_iv(const unsigned char *p) {
    return parse_iv2(p, NULL);
}

/* no need to check for length - re2c already did */
static inline size_t parse_uiv(const unsigned char *p) {
    unsigned char cursor;
    size_t result = 0;

    if (*p == '+') {
        p++;
    }

    while (1) {
        cursor = *p;
        if (cursor >= '0' && cursor <= '9') {
            result = result * 10 + (size_t) (cursor - (unsigned char) '0');
        } else {
            break;
        }
        p++;
    }
    return result;
}

inline int process_nested_data(UNSERIALIZE_PARAMETER, long elements, int objprops) {
    if (!objprops) {
        *rval = Object::New();
    }
    while (elements-- > 0) {
        Local<Value> key, data;

        if (!php_var_unserialize(&key, p, max)) {
            return 0;
        }

        /*if (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {
                //zval_dtor(key);
                //FREE_ZVAL(key);
                return 0;
        }*/

        if (!php_var_unserialize(&data, p, max)) {
            return 0;
        }

        if (!objprops) {
            if (key->IsNumber() || key->IsNumberObject()) {
                (*rval)->ToObject()->Set(key, data);
            }
            if (key->IsString() || key->IsStringObject()) {
                (*rval)->ToObject()->Set(key, data);
            }
        } else {
            *rval = key->ToString();
        }

        if (elements && *(*p - 1) != ';' && *(*p - 1) != '}') {
            (*p)--;
            return 0;
        }
    }

    return 1;
}

static inline int finish_nested_data(UNSERIALIZE_PARAMETER) {
    if (*((*p)++) == '}')
        return 1;
    return 0;
}

Handle<Number> zend_strtod(const char *s) {
    int len = 0;
    while (s[len++] != ';') {
    }
    return String::New(s, len - 1)->ToNumber();
}

static char *unserialize_str(const unsigned char **p, size_t *len, size_t maxlen) {
    size_t i, j;
    char *str = new char[*len + 1]; //safe_emalloc(*len, 1, 1);
    unsigned char *end = *(unsigned char **) p + maxlen;

    if (end < *p) {
        delete str;
        return NULL;
    }

    for (i = 0; i < *len; i++) {
        if (*p >= end) {
            delete str;
            return NULL;
        }
        if (**p != '\\') {
            str[i] = (char) **p;
        } else {
            unsigned char ch = 0;

            for (j = 0; j < 2; j++) {
                (*p)++;
                if (**p >= '0' && **p <= '9') {
                    ch = (ch << 4) + (**p - '0');
                } else if (**p >= 'a' && **p <= 'f') {
                    ch = (ch << 4) + (**p - 'a' + 10);
                } else if (**p >= 'A' && **p <= 'F') {
                    ch = (ch << 4) + (**p - 'A' + 10);
                } else {
                    delete str;
                    return NULL;
                }
            }
            str[i] = (char) ch;
        }
        (*p)++;
    }
    str[i] = 0;
    *len = i;
    return str;
}

#define YYFILL(n) do { } while (0)
#define YYCTYPE unsigned char
#define YYCURSOR cursor
#define YYLIMIT limit
#define YYMARKER marker

int php_var_unserialize(Handle<Value> *rval, const unsigned char **p, const unsigned char *max) {
    const unsigned char *cursor, *limit, *marker, *start;

    limit = cursor = *p;

    start = cursor;

    {
        YYCTYPE yych;
        static const unsigned char yybm[] = {
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            128, 128, 128, 128, 128, 128, 128, 128,
            128, 128, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
        };

        if ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);
        yych = *YYCURSOR;
        switch (yych) {
            case 'C':
            case 'O': goto yy13; //php object e.g. StdClass
            case 'N': goto yy5; //null
            case 'R': goto yy2;
            case 'S': goto yy10;
            case 'a': goto yy11; //Array && Object
            case 'b': goto yy6; //Boolean
            case 'd': goto yy8; //Double
            case 'i': goto yy7; //Uint32
            case 'o': goto yy12;
            case 'r': goto yy4;
            case 's': goto yy9; //String
            case '}': goto yy14;
            default: goto yy16;
        }
yy2:
        yych = *(YYMARKER = ++YYCURSOR);
        if (yych == ':') goto yy95;
yy3:
        {
            return 0;
        }
yy4:
        yych = *(YYMARKER = ++YYCURSOR);
        if (yych == ':') goto yy89;
        goto yy3;
yy5:
        yych = *++YYCURSOR;
        if (yych == ';') goto yy87;
        goto yy3;
yy6:
        yych = *(YYMARKER = ++YYCURSOR);
        if (yych == ':') goto yy83;
        goto yy3;
yy7:
        yych = *(YYMARKER = ++YYCURSOR);
        if (yych == ':') goto yy77;
        goto yy3;
yy8:
        yych = *(YYMARKER = ++YYCURSOR);
        if (yych == ':') goto yy53;
        goto yy3;
yy9:
        yych = *(YYMARKER = ++YYCURSOR);
        if (yych == ':') goto yy46;
        goto yy3;
yy10:
        yych = *(YYMARKER = ++YYCURSOR);
        if (yych == ':') goto yy39;
        goto yy3;
yy11:
        yych = *(YYMARKER = ++YYCURSOR);
        if (yych == ':') goto yy32;
        goto yy3;
yy12:
        yych = *(YYMARKER = ++YYCURSOR);
        if (yych == ':') goto yy25;
        goto yy3;
yy13:
        yych = *(YYMARKER = ++YYCURSOR);
        if (yych == ':') goto yy17;
        goto yy3;
yy14:
        ++YYCURSOR;
        {
            /* this is the case where we have less data than planned */

            *rval = ThrowException(Exception::Error(String::New("Unexpected end of serialized data")));
            return 0; /* not sure if it should be 0 or 1 here? */
        }
yy16:
        yych = *++YYCURSOR;
        goto yy3;
yy17:
        yych = *++YYCURSOR;
        if (yybm[0 + yych] & 128) {
            goto yy20;
        }
        if (yych == '+') goto yy19;
yy18:
        YYCURSOR = YYMARKER;
        goto yy3;
yy19:
        yych = *++YYCURSOR;
        if (yybm[0 + yych] & 128) {
            goto yy20;
        }
        goto yy18;
yy20:
        ++YYCURSOR;
        if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
        yych = *YYCURSOR;
        if (yybm[0 + yych] & 128) {
            goto yy20;
        }
        if (yych != ':') goto yy18;
        yych = *++YYCURSOR;
        if (yych != '"') goto yy18;
        ++YYCURSOR;
        //do not unserialize php class here
        return 0;
yy25:
        yych = *++YYCURSOR;
        if (yych <= ',') {
            if (yych != '+') goto yy18;
        } else {
            if (yych <= '-') goto yy26;
            if (yych <= '/') goto yy18;
            if (yych <= '9') goto yy27;
            goto yy18;
        }
yy26:
        yych = *++YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych >= ':') goto yy18;
yy27:
        ++YYCURSOR;
        if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
        yych = *YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy27;
        if (yych >= ';') goto yy18;
        yych = *++YYCURSOR;
        if (yych != '"') goto yy18;
        ++YYCURSOR;
        // do not unserialize php object here
        return 0;

yy32:
        yych = *++YYCURSOR;
        if (yych == '+') goto yy33;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy34;
        goto yy18;
yy33:
        yych = *++YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych >= ':') goto yy18;
yy34:
        ++YYCURSOR;
        if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
        yych = *YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy34;
        if (yych >= ';') goto yy18;
        yych = *++YYCURSOR;
        if (yych != '{') goto yy18;
        ++YYCURSOR;
        {
            long elements = parse_iv(start + 2);
            /* use iv() not uiv() in order to check data range */
            *p = YYCURSOR;

            if (elements < 0) {
                return 0;
            }
            //TODO 处理嵌套结构

            if (!process_nested_data(UNSERIALIZE_PASSTHRU, elements, 0)) {
                return 0;
            }

            return finish_nested_data(UNSERIALIZE_PASSTHRU);
        }
yy39:
        yych = *++YYCURSOR;
        if (yych == '+') goto yy40;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy41;
        goto yy18;
yy40:
        yych = *++YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych >= ':') goto yy18;
yy41:
        ++YYCURSOR;
        if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
        yych = *YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy41;
        if (yych >= ';') goto yy18;
        yych = *++YYCURSOR;
        if (yych != '"') goto yy18;
        ++YYCURSOR;
        {
            size_t len, maxlen;
            char *str;

            len = parse_uiv(start + 2);
            maxlen = max - YYCURSOR;
            if (maxlen < len) {
                *p = start + 2;
                return 0;
            }

            if ((str = unserialize_str(&YYCURSOR, &len, maxlen)) == NULL) {
                return 0;
            }

            if (*(YYCURSOR) != '"') {
                delete str;
                *p = YYCURSOR;
                return 0;
            }

            YYCURSOR += 2;
            *p = YYCURSOR;

            *rval = String::New(str);
            //delete str; //free after use
            return 1;
        }
yy46:
        yych = *++YYCURSOR;
        if (yych == '+') goto yy47;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy48;
        goto yy18;
yy47:
        yych = *++YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych >= ':') goto yy18;
yy48:
        ++YYCURSOR;
        if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
        yych = *YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy48;
        if (yych >= ';') goto yy18;
        yych = *++YYCURSOR;
        if (yych != '"') goto yy18;
        ++YYCURSOR;
        {
            size_t len, maxlen;
            char *str;

            len = parse_uiv(start + 2);
            maxlen = max - YYCURSOR;
            if (maxlen < len) {
                *p = start + 2;
                return 0;
            }

            str = (char*) YYCURSOR;

            YYCURSOR += len;

            if (*(YYCURSOR) != '"') {
                *p = YYCURSOR;
                return 0;
            }

            YYCURSOR += 2;
            *p = YYCURSOR;

            *rval = String::New(str, len);
            //delete str; //free after use
            return 1;
        }
yy53:
        yych = *++YYCURSOR;
        if (yych <= '/') {
            if (yych <= ',') {
                if (yych == '+') goto yy57;
                goto yy18;
            } else {
                if (yych <= '-') goto yy55;
                if (yych <= '.') goto yy60;
                goto yy18;
            }
        } else {
            if (yych <= 'I') {
                if (yych <= '9') goto yy58;
                if (yych <= 'H') goto yy18;
                goto yy56;
            } else {
                if (yych != 'N') goto yy18;
            }
        }
        yych = *++YYCURSOR;
        if (yych == 'A') goto yy76;
        goto yy18;
yy55:
        yych = *++YYCURSOR;
        if (yych <= '/') {
            if (yych == '.') goto yy60;
            goto yy18;
        } else {
            if (yych <= '9') goto yy58;
            if (yych != 'I') goto yy18;
        }
yy56:
        yych = *++YYCURSOR;
        if (yych == 'N') goto yy72;
        goto yy18;
yy57:
        yych = *++YYCURSOR;
        if (yych == '.') goto yy60;
        if (yych <= '/') goto yy18;
        if (yych >= ':') goto yy18;
yy58:
        ++YYCURSOR;
        if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
        yych = *YYCURSOR;
        if (yych <= ':') {
            if (yych <= '.') {
                if (yych <= '-') goto yy18;
                goto yy70;
            } else {
                if (yych <= '/') goto yy18;
                if (yych <= '9') goto yy58;
                goto yy18;
            }
        } else {
            if (yych <= 'E') {
                if (yych <= ';') goto yy63;
                if (yych <= 'D') goto yy18;
                goto yy65;
            } else {
                if (yych == 'e') goto yy65;
                goto yy18;
            }
        }
yy60:
        yych = *++YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych >= ':') goto yy18;
yy61:
        ++YYCURSOR;
        if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
        yych = *YYCURSOR;
        if (yych <= ';') {
            if (yych <= '/') goto yy18;
            if (yych <= '9') goto yy61;
            if (yych <= ':') goto yy18;
        } else {
            if (yych <= 'E') {
                if (yych <= 'D') goto yy18;
                goto yy65;
            } else {
                if (yych == 'e') goto yy65;
                goto yy18;
            }
        }
yy63:
        ++YYCURSOR;
        {
#if SIZEOF_LONG == 4
use_double:
#endif
            *p = YYCURSOR;
            //ZVAL_DOUBLE(*rval, zend_strtod((const char *)start + 2, NULL));
            *rval = zend_strtod((const char *) start + 2);
            return 1;
        }
yy65:
        yych = *++YYCURSOR;
        if (yych <= ',') {
            if (yych != '+') goto yy18;
        } else {
            if (yych <= '-') goto yy66;
            if (yych <= '/') goto yy18;
            if (yych <= '9') goto yy67;
            goto yy18;
        }
yy66:
        yych = *++YYCURSOR;
        if (yych <= ',') {
            if (yych == '+') goto yy69;
            goto yy18;
        } else {
            if (yych <= '-') goto yy69;
            if (yych <= '/') goto yy18;
            if (yych >= ':') goto yy18;
        }
yy67:
        ++YYCURSOR;
        if (YYLIMIT <= YYCURSOR) YYFILL(1);
        yych = *YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy67;
        if (yych == ';') goto yy63;
        goto yy18;
yy69:
        yych = *++YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy67;
        goto yy18;
yy70:
        ++YYCURSOR;
        if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
        yych = *YYCURSOR;
        if (yych <= ';') {
            if (yych <= '/') goto yy18;
            if (yych <= '9') goto yy70;
            if (yych <= ':') goto yy18;
            goto yy63;
        } else {
            if (yych <= 'E') {
                if (yych <= 'D') goto yy18;
                goto yy65;
            } else {
                if (yych == 'e') goto yy65;
                goto yy18;
            }
        }
yy72:
        yych = *++YYCURSOR;
        if (yych != 'F') goto yy18;
yy73:
        yych = *++YYCURSOR;
        if (yych != ';') goto yy18;
        ++YYCURSOR;
        {
            *p = YYCURSOR;

            if (!strncmp((const char *) start + 2, "NAN", 3)) {
                *rval = Number::New(V8_SNAN);
            } else if (!strncmp((const char *) start + 2, "INF", 3)) {
                *rval = Number::New(DoubleFromBits(V8_INFINITY));
            } else if (!strncmp((const char *) start + 2, "-INF", 4)) {
                *rval = Number::New(DoubleFromBits(V8_NEG_INFINITY));
            }

            return 1;
        }
yy76:
        yych = *++YYCURSOR;
        if (yych == 'N') goto yy73;
        goto yy18;
yy77:
        yych = *++YYCURSOR;
        if (yych <= ',') {
            if (yych != '+') goto yy18;
        } else {
            if (yych <= '-') goto yy78;
            if (yych <= '/') goto yy18;
            if (yych <= '9') goto yy79;
            goto yy18;
        }
yy78:
        yych = *++YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych >= ':') goto yy18;
yy79:
        ++YYCURSOR;
        if (YYLIMIT <= YYCURSOR) YYFILL(1);
        yych = *YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy79;
        if (yych != ';') goto yy18;
        ++YYCURSOR;
        {
#if SIZEOF_LONG == 4
            int digits = YYCURSOR - start - 3;

            if (start[2] == '-' || start[2] == '+') {
                digits--;
            }

            /* Use double for large long values that were serialized on a 64-bit system */
            if (digits >= MAX_LENGTH_OF_LONG - 1) {
                if (digits == MAX_LENGTH_OF_LONG - 1) {
                    int cmp = strncmp((const char *) YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);

                    if (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {
                        goto use_double;
                    }
                } else {
                    goto use_double;
                }
            }
#endif
            *p = YYCURSOR;
            //ZVAL_LONG(*rval, parse_iv(start + 2));
            *rval = Number::New(parse_iv(start + 2)); // Mark: not sure
            return 1;
        }
yy83:
        yych = *++YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych >= '2') goto yy18;
        yych = *++YYCURSOR;
        if (yych != ';') goto yy18;
        ++YYCURSOR;
        {
            *p = YYCURSOR;
            *rval = Boolean::New(parse_iv(start + 2));
            return 1;
        }
yy87:
        ++YYCURSOR;
        {
            *p = YYCURSOR;
            *rval = Null();
            return 1;
        }
yy89:
        yych = *++YYCURSOR;
        if (yych <= ',') {
            if (yych != '+') goto yy18;
        } else {
            if (yych <= '-') goto yy90;
            if (yych <= '/') goto yy18;
            if (yych <= '9') goto yy91;
            goto yy18;
        }
yy90:
        yych = *++YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych >= ':') goto yy18;
yy91:
        ++YYCURSOR;
        if (YYLIMIT <= YYCURSOR) YYFILL(1);
        yych = *YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy91;
        if (yych != ';') goto yy18;
        ++YYCURSOR;
        {
            long id;

            *p = YYCURSOR;
            //if (!var_hash) return 0;

            id = parse_iv(start + 2) - 1;
            if (id == -1/* || var_access(var_hash, id, &rval_ref) != SUCCESS*/) {
                return 0;
            }
            //TODO
            //if (*rval == *rval_ref) return 0;

            /*if (*rval != NULL) {
                    zval_ptr_dtor(rval);
            }
             *rval = *rval_ref;*/
            //Z_ADDREF_PP(rval);
            //Z_UNSET_ISREF_PP(rval);

            return 1;
        }
yy95:
        yych = *++YYCURSOR;
        if (yych <= ',') {
            if (yych != '+') goto yy18;
        } else {
            if (yych <= '-') goto yy96;
            if (yych <= '/') goto yy18;
            if (yych <= '9') goto yy97;
            goto yy18;
        }
yy96:
        yych = *++YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych >= ':') goto yy18;
yy97:
        ++YYCURSOR;
        if (YYLIMIT <= YYCURSOR) YYFILL(1);
        yych = *YYCURSOR;
        if (yych <= '/') goto yy18;
        if (yych <= '9') goto yy97;
        if (yych != ';') goto yy18;
        ++YYCURSOR;
        {
            long id;

            *p = YYCURSOR;
            //if (!var_hash) return 0;
            //TODO
            id = parse_iv(start + 2) - 1;
            if (id == -1 /*|| var_access(var_hash, id, &rval_ref) != SUCCESS*/) {
                return 0;
            }
            *rval = Null(); // Mark: wait data to rewrite
            /*if (*rval != NULL) {
                    zval_ptr_dtor(rval);
            }
             *rval = *rval_ref;*/
            //Z_ADDREF_PP(rval);
            //Z_SET_ISREF_PP(rval);

            return 1;
        }
    }


    return 0;
}
